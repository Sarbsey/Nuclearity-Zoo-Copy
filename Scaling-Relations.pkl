# Import libraries
import pickle
import numpy as np
import pandas as pd
import plotly.express as px
import dash
import dash_core_components as dcc
import dash_html_components as html
import re
from dash.dependencies import Input, Output
pd.options.plotting.backend = "plotly"

# Open data
with open('OCP_new.pkl', 'rb') as f:
    data = pickle.load(f)

data = pd.DataFrame.from_dict(data)

# Find all unique Adsorbate pairs
ads_pairs = data['adsorbates'].unique()
ads_pairs_dropdown = []
for i in ads_pairs:
    ads_pairs_dropdown.append({'label': i, 'value': i})

# Find the minimum and maximum energy for the E filtering range
## Note max is not super ideal because this is before we have aggregated over
## the min e values
e_min = data['energy_x'].min()
e_min = int(np.floor(e_min))
e_max = data['energy_x'].max()
e_max = int(np.ceil(e_max))

# Create a function to evaluate if the e val lies in the desired range
def between2(val1, val2, low,high):
    if val1 >= low and val2 >= low and val1 <= high and val2 <= high:
        return True
    else:
        return False

# Initialize dash layout elements
external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)
server = app.server

# Invert the row and col dictionaries so that the AN can by used to look up the row /col
num_to_row = {1:1, 2:1, 3:2, 4:2, 5:2, 6:2, 7:2, 8:2,
9:2, 10:2, 11:3, 12:3, 13:3, 14:3, 15:3, 16:3, 17:3,
18:3, 19:4, 20:4, 21:4, 22:4, 23:4, 24:4, 25:4, 26:4,
27:4, 28:4, 29:4, 30:4, 31:4, 32:4, 33:4, 34:4, 35:4,
36:4, 37:5, 38:5, 39:5, 40:5, 41:5, 42:5, 43:5, 44:5,
45:5, 46:5, 47:5, 48:5, 49:5, 50:5, 51:5, 52:5, 53:5,
54:5, 55:6, 56:6, 57:6, 58:6, 59:6, 60:6, 61:6, 62:6,
63:6, 64:6, 65:6, 66:6, 67:6, 68:6, 69:6, 70:6, 71:6,
72:6, 73:6, 74:6, 75:6, 76:6, 77:6, 78:6, 79:6, 80:6,
81:6, 82:6, 83:6, 84:6, 85:6, 86:6, 87:7, 88:7, 89:7,
90:7, 91:7, 92:7, 93:7, 94:7, 95:7, 96:7, 97:7, 98:7,
99:7, 100:7, 101:7, 102:7, 103:7, 104:7, 105:7, 106:7,
107:7, 108:7, 109:7, 110:7, 111:7, 112:7, 113:7, 114:7,
115:7, 116:7, 117:7, 118:7}

num_to_col = {1:1, 2:18, 3:1, 4:2, 5:13, 6:14, 7:15, 8:16,
9:17, 10:18, 11:1, 12:2, 13:13, 14:14, 15:15, 16:16, 17:17,
18:18, 19:1, 20:2, 21:3, 22:4, 23:5, 24:6, 25:7, 26:8,
27:9, 28:10, 29:11, 30:12, 31:13, 32:14, 33:15, 34:16, 35:17,
36:18, 37:1, 38:2, 39:3, 40:4, 41:5, 42:6, 43:7, 44:8,
45:9, 46:10, 47:11, 48:12, 49:13, 50:14, 51:15, 52:16, 53:17,
54:18, 55:1, 56:2, 57:3,
72:4, 73:5, 74:6, 75:7, 76:8, 77:9, 78:10, 79:11, 80:12,
81:13, 82:14, 83:15, 84:16, 85:17, 86:18, 87:1, 88:2, 89:3,
104:4, 105:5, 106:6,
107:7, 108:8, 109:9, 110:10, 111:11, 112:12, 113:13, 114:14,
115:15, 116:16, 117:17, 118:18}

# Create markdown text for interface
markdown_text1 = '''
 #### Select how many unique elements in the bulk material:
'''
markdown_text2 = '''
#### Filter the data by selecting a range of elements.
Any bulks that contain one or more of the secified elements will be displayed.
'''

markdown_text3 = '''
#### Filter the data by selecting a range of rows from the periodic table.
Any bulks that contain one or more elements in the specified rows will be displayed.
'''

markdown_text4 = '''
#### Filter the data by selecting a range of columns from the periodic table.
Any bulks that contain one or more elements in the specified columns will be displayed.
'''

markdown_text5 = '''
#### Select which type of graph you would like to view
* Trendline will display the results with a trendline.
* Display all data will allow you to view all the data, but the data you have
filtered for will be highlighted in a different color.
* Residual mapping will highlight how far points lie from the best-fit line
using a color mapping. The color-value is the number of standard deviations
about the mean of the residuals.
'''
markdown_text6 = '''
#### Filter the data by selecting a range of energy values.
Any bulk with an energy value of either adsorbate with an energy value out of
range will be filtered out.
'''

# Create the plotly dash layout
app.layout = html.Div(children=[
    html.H1(children='Scaling Relations'),

    # Dropdown bar so the user may select which scaling pair to view
    dcc.Dropdown(
        options=[
            *ads_pairs_dropdown
        ],
        value=f'{ads_pairs[0]}',
        id = 'Adsorbates'
    ),


    # Output text for the linear Regression
    html.Div(id = 'Linear Regression', style={'color': '#6699FF', 'fontSize': 20}),

    # Initialize the figure
    dcc.Graph(
        id='Scaling Relation',
    ),

    # Markdown for element filtering
    dcc.Markdown(children=markdown_text2),

    # Initialize the slider bar for data filtering by atomic number
    html.Label('Atomic Number'),
    dcc.RangeSlider(
        id = 'element-num',
        min=1,
        max=118,
        marks={i:  '' if (i % 4 != 0)  else str(i) for i in range(1, 119)},
        value=[1,118]
    ),

    # Markdown for row filtering
    dcc.Markdown(children=markdown_text3),

    # Initialize the slider bar for data filtering by row number
    html.Label('Row Number'),
    dcc.RangeSlider(
        id = 'element-row',
        min=1,
        max=7,
        marks={i:  '{}'.format(i) if i == 1 else str(i) for i in range(1, 8)},
        value = [1,7]
    ),

    # Markdown for column filtering
    dcc.Markdown(children=markdown_text4),

    # Initialize the slider bar for filtering by column number
    html.Label('Column Number'),
    dcc.RangeSlider(
        id = 'element-col',
        min=1,
        max=18,
        marks={i: '{}'.format(i) if i == 1 else str(i) for i in range(1, 19)},
        value=[1,18]
    ),

    # Markdown for energy filtering
    dcc.Markdown(children=markdown_text6),

    #Filter slider for energy
    html.Label('Energy Range'),
    dcc.RangeSlider(
        id = 'energy-range',
        min= e_min,
        max= e_max,
        marks={i:  '' if (i % 4 != 0)  else str(i) for i in range(e_min,e_max+1)},
        value=[e_min, e_max]
    ),

    # Markdown for the graph type selection
    dcc.Markdown(children=markdown_text5),

    # Initialize the button selection for what type of chart to view
    dcc.RadioItems(
                id='button',
                options=[{'label': i, 'value': i} for i in ['Trendline',
                'Display all data','Residual Mapping']],
                value='Trendline',
                labelStyle={'display': 'inline-block'}
            ),
    # Markdown for the element number checklist
    dcc.Markdown(children=markdown_text1),

    dcc.Checklist(
    id='num-el',
    options=[
        {'label': '1', 'value': '1'},
        {'label': '2', 'value': '2'},
        {'label': '3', 'value': '3'}
    ],
    value=['1', '2','3']
)

])

# Create a linear regression function. This is necessary for its results to be
# displayed on the callback (update with filtering)
def update_linregress(df, mask):
    data_count = len(df[mask])
    # Return that no data is selected in place of the trendline info
    if data_count == 0:
        return html.Div(children = ['No data is selected'])
    # Return that only one point is selected (therefore no trendline)
    elif data_count == 1:
        return html.Div(children = ['Only one point selected'])
    # Return the linear regression information (normal mode)
    else:
        line = np.polynomial.polynomial.polyfit(df[mask]['energy_x'].to_numpy(),
        df[mask]['energy_y'].to_numpy(),1)
        slope = line[1]
        intercept = line[0]
        ret_str = f'y = {slope:1.2f} x + {intercept:1.2f}'
        return html.Div(children = [ret_str])

# Create dash callback
@app.callback(
    Output('Scaling Relation', 'figure'),
    Output('Linear Regression', 'children'),
    Input('Adsorbates','value'),
    Input('element-num', 'value'),
    Input('element-row','value'),
    Input('element-col', 'value'),
    Input('energy-range', 'value'),
    Input('button','value'),
    Input('num-el','value'))

# Primary callback function
def update_element(adsorbate, el_range, row_range, col_range, e_range, ndr, num_el):
    # Select which dataframe to parse from
    selected_df = data[data['adsorbates'] == adsorbate]
    selected_df = selected_df.reset_index(drop = True)

    # Create a string for axis labels
    ads = adsorbate.split('-')

    # Create a mask (to filter displayed data)
    ## Initialize empty masks (reset for callback)
    mask = pd.Series([],dtype = object)
    mask_el = pd.Series([],dtype = object)

    ## Unpack the slider ranges
    low_num, high_num = el_range
    low_row, high_row = row_range
    low_col, high_col = col_range
    low_e, high_e = e_range

    ## Create a list of all integer values in the selected range for rows, cols,
    ## and atomic number
    hl_num_list = list(range(low_num, high_num + 1))
    hl_row_list = list(range(low_row, high_row + 1))
    hl_col_list = list(range(low_col, high_col + 1))

    ## Assoign a value to num_el if it is empty
    if not num_el:
        num_el = [0]

    ## Convert the list to a set
    selected_atomic_num = {*hl_num_list}
    selected_row = {*hl_row_list}
    selected_col = {*hl_col_list}

    ## Initialize the mask based upon element filtering (row, col, atomic num)
    mask_el = [True if ((str(len(element_list)) in num_el) and selected_atomic_num.intersection(set(element_list))
    and selected_row.intersection(set(num_to_row[x] for x in element_list))
    and selected_col.intersection(set(num_to_col[y] for y in element_list))) else False
        for element_list in selected_df['elements']]

    ## Complete the mask based upon additional filters (energy range)
    mask = [True if (mask_el[counter] and between2(selected_df['energy_x'][counter], selected_df['energy_y'][counter], low_e, high_e))  else False
        for counter in range(len(mask_el))]

    # Create the figure
    ## Display all data is selected
    if ndr == 'Display all data':
        selected_df['filter'] = mask
        fig = px.scatter(selected_df, x = 'energy_x', y ='energy_y', color = 'filter',
                         labels={
                             "energy_x": f"*{ads[0]} energy dE [eV]",
                             "energy_y": f"*{ads[1]} energy dE [eV]",
                             "filter": "Selected?"
                         },
                         custom_data = ['mpid','formula', 'miller','top','shift'],
                         )
        results = px.get_trendline_results(fig)

        # Create custom hoverplate for more information to be included
        fig.update_traces(
            hovertemplate="<br>".join([
                "*C energy dE [eV]: %{x}",
                "*CH energy dE [eV]: %{y}",
                "mpid: %{customdata[0]}",
                "chemical formula: %{customdata[1]}",
                "miller index: %{customdata[2]}",
                "top?: %{customdata[3]}",
                "shift: %{customdata[4]}"
            ])
        )
        children = update_linregress(selected_df, mask)

    ## Trendline is selected
    elif ndr == 'Trendline':
        fig = px.scatter(selected_df[mask], x = 'energy_x', y ='energy_y', # trendline = 'ols',
                         labels={
                             "energy_x": f"*{ads[0]} energy dE [eV]",
                             "energy_y": f"*{ads[1]} energy dE [eV]"
                         },
                         custom_data = ['mpid','formula', 'miller','top','shift'],
                         )
        results = px.get_trendline_results(fig)

        # Create custom hoverplate for more information to be included
        fig.update_traces(
            hovertemplate="<br>".join([
                "*C energy dE [eV]: %{x}",
                "*CH energy dE [eV]: %{y}",
                "mpid: %{customdata[0]}",
                "chemical formula: %{customdata[1]}",
                "miller index: %{customdata[2]}",
                "top?: %{customdata[3]}",
                "shift: %{customdata[4]}"
            ])
        )
        children = update_linregress(selected_df, mask)

    ## Residual mapping is selected
    else:
        # If statement to deal with case where no data is selected
        if len(selected_df[mask]) == 0:
            slope = 0
            intercept = 0
        # Calculate the bestfit line so the residuals may be calculated
        else:
            line = np.polynomial.polynomial.polyfit(df[mask]['energy_x'].to_numpy(),
            df[mask]['energy_y'].to_numpy(),1)
            slope = line[1]
            intercept = line[0]

        # Create an array of residuals and append to the dataframe
        temp = abs((selected_df['energy_x'] * slope + intercept) -selected_df['energy_y'])
        selected_df['residuals'] = temp / np.std(temp)

        # Create the figure
        fig = px.scatter(selected_df[mask], x = 'energy_x', y ='energy_y', color = 'residuals',
                         color_continuous_scale = 'jet', range_color=[0,4],
                         labels={
                             "energy_x": f"*{ads[0]} energy dE [eV]",
                             "energy_y": f"*{ads[1]} energy dE [eV]"
                         },
                         custom_data = ['mpid','formula', 'miller','top','shift'],
                         )

        # Create custom hoverplate for more information to be included
        fig.update_traces(
            hovertemplate="<br>".join([
                "*C energy dE [eV]: %{x}",
                "*CH energy dE [eV]: %{y}",
                "mpid: %{customdata[0]}",
                "chemical formula: %{customdata[1]}",
                "miller index: %{customdata[2]}",
                "top?: %{customdata[3]}",
                "shift: %{customdata[4]}"
            ])
        )

        # Call upon the linear regress function to update the line + r-sq info
        children = update_linregress(selected_df, mask)

    fig.update_layout(transition_duration=500)
    return fig, children


if __name__ == '__main__':
    app.run_server(debug=True)
